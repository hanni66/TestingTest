# Unit Test 연습하기

테스트를 작성하기 전 기본 사항

- 핵심 기능 모델 클래스, 메서드 및 컨트롤러와의 상호 작용
- 가장 일반적인 UI 워크플로(workflow)
- 경계 조건 (Boundary conditions)
- 버그 수정

# Unit Test란?

→ 사용하려는 기능이 개발자의 의도에 맞게 동작하는지 테스트를 하는 작업이다.

**"FIRST"** 원칙

**Fast (속도)**

- 빠른 속도로 테스트를 수행할 수 있도록 설계

**Independent / Isolated (독립적)**

- 각각의 테스트가 서로 독립적으로 실행 되어야 함. (특정 테스트의 결과가 다른 테스트에 영향을 미치지 않고 독립적으로 실행한다.)
- 효과 : 코드 변경에 대해 신속하게 반응 할 수 있다

**Repeatable (반복적)**

- 동일한 입력값에 대해 항상 동일한 결과를 보여야 함.
- 실행 순서나 실행환경이 달라져도 동일한 결과를 보여주어야 한다.
- 효과 : 테스트의 신뢰성을 높이기 위함.

**Self-Automation (자동화) / Self-validating(자가 검증)**

- 테스트를 실행하고 결과를 확인하는 모든 과정을 자동으로 처리하는 것
- 출력은 로그 파일에 대한 프로그래머의 해석에 의존하지 않고 “`통과`” 또는 “`실패`“여야 한다.
- 효과 : 시간과 비용 절약
- 코드를 변경하거나 기능을 추가할 때마다 쉽게 실행할 수 있어서 버그를 빠르게 찾을 수 있음.

**Timely (시점)**

- 코드가 수정되어 다른 부분에 영향을 미치지 않았는지 확인할 수 있는 시점에 테스트를 실행함.
- 이상적으로는 테스트하는 프로덕션 코드를 작성하기 전에 테스트를 작성해야 합니다. → 테스트 주도 개발(TDD)
- 효과 : 코드 수정 후 변경사항을 더 빠르게 확인할 수 있도록 도와줌.

## Commit : 모델을 테스트하고 테스트 실패를 디버그하는 방법

`XCTAssert` 함수를 사용하여 `BullsEye` 모델의 핵심 기능을 테스트한다. 

`BullsEyeGame`이 라운드의 점수를 올바르게 계산하고 있을까?

## Commit : XCTestExpectation을 사용하여 비동기 작업(Asynchronous Operations) 테스트

`BullsEyeGame`은 `URLSession`을 사용하여 다음 게임의 대상으로 임의의 숫자를 가져온다.

`URLSession` 메서드는 비동기 방식이다. 즉시 반환되지만 실행이 완료되지는 않는다. 비동기식 메서드를 테스트하려면 `XCTestExpectation`을 사용하여 비동기식 작업이 완료될 때까지 테스트를 기다려야 한다.

비동기 테스트는 일반적으로 느리므로 더 빠른 단위 테스트와 별도로 격리해야 한다.

`BullsEyeSlowTests`라는 새 단위 테스트 대상을 만든다. 새로운 테스트 클래스 `BullsEyeSlowTests`를 열고 기존 `import` 문 바로 아래에 `BullsEye` 앱 모듈을 가져온다.

## Commit : Faking object와 상호 작용

비동기 테스트는 코드가 비동기 API에 대한 올바른 입력을 생성한다는 확신을 준다. 또한 `URLSession`에서 입력을 수신할 때 코드가 올바르게 작동하는지 또는 `UserDefaults` 데이터베이스 또는 iCloud 컨테이너를 올바르게 업데이트하는지 테스트할 수도 있다.

대부분의 앱은 시스템 또는 라이브러리 객체(당신이 제어하지 않는 객체)와 상호 작용한다. 이러한 객체와 상호 작용하는 테스트는 느리고 반복할 수 없으며 두 가지 FIRST 원칙을 위반할 수 있다. 대신 stub에서 입력을 받거나 mock objects를 업데이트하여 상호 작용을 가짜로 만들 수 있다.

코드에 시스템 또는 라이브러리 개체에 대한 종속성이 있는 경우 가짜를 사용한다. 그 역할을 할 가짜 객체를 만들고 이 가짜를 코드에 주입하면 된다.

- Stub에서 가짜 입력
- Mock object로 가짜 업데이트 **(Commit : Mock object와 상호 작용)**

## Commit : Xcode에서 UI테스트

UI 테스트를 통해 사용자 인터페이스와의 상호 작용을 테스트할 수 있다. UI 테스트는 쿼리로 앱의 UI 개체를 찾고 이벤트를 합성한 다음 해당 개체에 이벤트를 보내는 방식으로 작동한다. API를 사용하면 UI 개체의 속성 및 상태를 검사하여 예상 상태와 비교할 수 있다.

## Commit : 성능 테스트

- **[Apple 문서](https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/04-writing_tests.html#//apple_ref/doc/uid/TP40014132-CH4-SW8)**

성능 테스트는 평가하려는 코드 블록을 가져와서 10번 실행하여 실행에 대한 평균 실행 시간과 표준 편차를 수집한다. 이러한 개별 측정값의 평균은 테스트 실행에 대한 값을 형성한 다음 기준선(baseline)과 비교하여 성공 또는 실패를 평가할 수 있다.

# Code Coverage

→ Code Coverage는 소프트웨어 개발 과정에서 중요한 메트릭으로, 소스 코드 중에서 테스트 스위트(테스트 케이스)를 실행하여 얼마나 많은 코드가 실행되었는지를 측정하는 지표이다. 

일반적으로 백분율로 표시되며, 100% Code Coverage는 테스트가 모든 코드 경로를 통과했음을 의미한다.

### **Code Coverage를 하는 이유**

1. **테스트 품질 평가**: Code Coverage를 사용하면 어떤 부분이 테스트되지 않았는지 파악할 수 있으므로 테스트 스위트의 품질을 평가할 수 있다.
2. **버그 예방**: Code Coverage를 높이면 포획되지 않은 버그를 식별하고 예방할 수 있다. 더 높은 Code Coverage는 애플리케이션의 더 많은 부분을 테스트하므로 잠재적인 문제를 미리 발견할 수 있다.
3. **유지 보수 용이성**: Code Coverage를 높이면 코드 변경에 따른 파급 효과를 예측할 수 있다. 변경된 코드에 대한 테스트 스위트를 실행하여 시스템 안정성을 보장할 수 있다.

### **Code Coverage 규칙이 따로 있는 것인가?**

1. **라인 커버리지(Line Coverage)**: 소스 코드의 각 라인이 얼마나 많이 실행되었는지를 나타낸다. 일반적으로 100% 라인 커버리지를 목표로 한다.
2. **분기 커버리지(Branch Coverage)**: 조건문에서 분기한 각 경로가 얼마나 많이 실행되었는지를 나타낸다. 모든 분기 경로를 테스트하여 100% 분기 커버리지를 목표로 한다.
3. **함수 커버리지(Function Coverage)**: 각 함수가 얼마나 많이 호출되었는지를 나타낸다. 모든 함수가 최소한 한 번 이상 호출되었는지 확인한다.

### **Code Coverage를 높이는 좋은 작성 방법은 무엇일까?**

1. **테스트 주도 개발(TDD)**: 코드를 작성하기 전에 테스트를 먼저 작성하고 테스트를 통과시키기 위해 코드를 개발하는 방식을 사용한다.
2. **모든 경로 테스트**: 가능한 모든 코드 경로를 테스트하는 것이 중요하다. 예외 처리 코드나 에러 상황 처리 코드도 테스트 포함시켜야 한다.
3. **자동화된 테스트 스위트**: 자동화된 테스트 스위트를 만들어서 주기적으로 실행하도록 설정한다. 이를 통해 Code Coverage를 모니터링하고 변경 사항에 대한 영향을 파악할 수 있다.
4. **정적 코드 분석 도구 사용**: 정적 코드 분석 도구를 활용하여 잠재적인 문제를 식별하고 코드 커버리지를 향상시키는 데 도움을 받을 수 있다.

Code Coverage를 향상시키면 코드의 품질과 안정성을 높일 수 있으며, 버그를 미리 발견하고 수정하는 데 도움이 된다.

### 참고
- [iOS Unit Testing and UI Testing Tutorial](https://www.kodeco.com/21020457-ios-unit-testing-and-ui-testing-tutorial)
